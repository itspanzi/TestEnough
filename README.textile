*TestEnough* is an attempt at solving the problem of _reducing the feedback time_ around making sure if the changes made to a codebase are fine. It is a library that helps you run a pruned set of tests (a small subset) picked from the entire test suite based on the changes made to production code. Thus, instead of running all the tests, it lets you run only a small, relevant set of tests.

h2. Why?

Typically teams following _continuous integration_ make sure that developers run the build locally and then check in if the build is green. The idea is to keep the main line green as much as possible. However, even with a very fast build of a few minutes, developers need to wait for those few minutes if they are running the build on their box. Even if the build is moved to a personal build server of sorts, so that pre-commit build is not happening on the local developer box, a few minutes still need to be spent before checking in.

 On a large team, there could potentially be multiple commits during this few minutes window and you would then have to merge with upstream and re-run the build. It would be quite tedious if one gets into a merge-build loop.

 This means, ideally, you would want as small a pre-commit build as possible.

It also seems like a huge waste to run all tests when the change made is quite small. Especially, if a team follows the "Small checkin, frequent checkin" philosophy, it would definitely be wasteful to run all the tests all the time.

To address these, is why *TestEnough* came into existence.

h2. Getting started

* Get hold of the *TestEnough* package. You can either
** Download a stable build to get a tar ball or
** You can source compile. There is an ant build file in the source root. You can run @ant pkg@ in the checkout folder. This runs all the tests and generates the tar ball in _target/pkg_ folder.
* Extract the tar ball
* In order to hook up *TestEnough* to your tests, you need to add these JVM argument to your test running JVM. @-javaagent:test-enough/test-enough-0.1.jar=configFilePath:test-enough/config.properties=lib:test-enough/lib -Xbootclasspath/a:test-enough/lib/commons-io-2.0.1.jar@
** In the above arguments, if you notice, _you need to provide the path to 4 things_ - the *TestEnough* jar, the *TestEnough* configuration, the libraries on which *TestEnough* depends on and the commons-io jar. All these paths are to resources available inside the obtained tar ball.
** Its preferred to have the extracted directory checked in and the above paths referred to using relative paths
* If you are using *ANT* you can use *TestEnough* in 2 ways based on how you run your tests
** Fork Mode: If you run your JUnit tests using the _fork=true_ option, you need to pass the above arguments as 2 _<jvmarg>_ under _<junit>_ tag. 1 _<jvmarg>_ for the "javaagent" and the other for the "Xbootclasspath" options. Eg: @<jvmarg>-javaagent:test-enough/test-enough-0.1.jar=configFilePath:test-enough/config.properties=lib:test-enough/lib</jvmarg>
                                               <jvmarg>-Xbootclasspath/a:test-enough/lib/commons-io-2.0.1.jar</jvmarg>@
** Non-Fork Mode: If you are not forking your tests, then you need to set the environment variable "ANT_OPTS" with both the arguments as the value. Eg: @export ANT_OPTS="-javaagent:test-enough/test-enough-0.1.jar=configFilePath:test-enough/config.properties=lib:test-enough/lib -Xbootclasspath/a:test-enough/lib/commons-io-2.0.1.jar"@

 h2. How?

*TestEnough* is a Java agent library that uses *Byte Code Instrumentation* to figure out what methods were called. One can configure what is a test and what is production code which would then let *TestEnough* figure out what all code gets called from a given test. It maintains a map of "Method => [Tests]".

This way, when running a build, based on what methods of production code have changed, *TestEnough* constructs a smaller list of tests. You would have a new build task that would use *TestEnough* and run this as the pre-commit build

h2. Why TestEnough?

My wife thought it would be a good idea to name this after her. Her point was, I spend so much of my personal time hacking and since she is very supportive, why shouldn't I? We compromised by saying I will mention her intention instead here! (Here you go honey)